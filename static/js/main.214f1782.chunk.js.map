{"version":3,"sources":["components/Grid.js","shapes.js","components/Tetris.js","App.js","index.js"],"names":["Grid","props","colorClasses","grid","rows","i","length","row","j","colorClass","this","push","className","makeGrid","React","Component","Shape","coords","color","centerX","centerY","rotation","makeRotationOne","makeRotationTwo","makeRotationThree","makeRotationFour","map","coord","Line","TeeShape","SnakeShapeRight","SnakeShapeLeft","LShapeRight","LShapeLeft","Square","Tetris","gridWidth","gridHeight","fallingSpeed","allShapes","state","staticGrid","makeEmptyGrid","shape","getRandomShape","points","dropShape","setInterval","moveShapeDown","bind","window","addEventListener","handleUserInput","clearInterval","console","log","event","keyCode","moveShapeLeft","rotate","moveShapeRight","newCenterX","collides","setState","newRotation","newCenterY","resetShape","shapeIndices","makeIndices","index","joinShapeGrid","removeFilledRows","numFilledrows","newShape","currentPoints","filledRows","getFilledRows","sort","a","b","count","rowNum","splice","isFilledRow","col","getCurrentShapeIndices","getShapeIndices","randomIndex","Math","floor","random","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"oMAaqBA,E,kDACjB,WAAYC,GAAQ,IAAD,8BACf,cAAMA,IACDC,aAAe,EAAKD,MAAMC,aAFhB,E,4CAKnB,SAASC,GAEL,IADA,IAAIC,EAAO,GACFC,EAAI,EAAGA,EAAIF,EAAKG,OAAQD,IAAK,CAElC,IADA,IAAIE,EAAM,GACDC,EAAI,EAAGA,EAAIL,EAAK,GAAGG,OAAQE,IAAK,CACrC,IAAIC,EAAaC,KAAKR,aAAaC,EAAKE,GAAGG,IAC3CD,EAAII,KAAK,oBAAwBC,UAAWH,GAA1B,MAAQJ,EAAIG,IAElCJ,EAAKO,KAAK,6BAAqBJ,GAAZ,MAAQF,IAE/B,OAAO,uBAAOO,UAAWF,KAAKT,MAAMW,UAA7B,SAAwC,gCAAQR,Q,oBAG3D,WACI,OAAOM,KAAKG,SAASH,KAAKT,MAAME,U,GApBNW,IAAMC,W,eCZlCC,E,WACF,WAAYC,EAAQC,GAAQ,oBACxBR,KAAKO,OAASA,EACdP,KAAKQ,MAAQA,E,+CAGjB,SAAYC,EAASC,EAASC,GAC1B,OAAiB,IAAbA,EACOX,KAAKY,gBAAgBH,EAASC,GACjB,IAAbC,EACAX,KAAKa,gBAAgBJ,EAASC,GACjB,IAAbC,EACAX,KAAKc,kBAAkBL,EAASC,GACpB,GAAZC,EACAX,KAAKe,iBAAiBN,EAASC,QADnC,I,6BAKX,SAAgBD,EAASC,GACrB,OAAOV,KAAKO,OAAOS,KAAI,SAAAC,GAAK,MAAI,CAACR,EAAQQ,EAAM,GAAIP,EAAQO,EAAM,S,6BAGrE,SAAgBR,EAASC,GACrB,OAAOV,KAAKO,OAAOS,KAAI,SAAAC,GAAK,MAAI,CAACR,EAAQQ,EAAM,GAAIP,EAAQO,EAAM,S,+BAGrE,SAAkBR,EAASC,GACvB,OAAOV,KAAKO,OAAOS,KAAI,SAAAC,GAAK,MAAI,CAACR,EAAQQ,EAAM,GAAIP,EAAQO,EAAM,S,8BAGrE,SAAiBR,EAASC,GACtB,OAAOV,KAAKO,OAAOS,KAAI,SAAAC,GAAK,MAAI,CAACR,EAAQQ,EAAM,GAAIP,EAAQO,EAAM,W,KAK9DC,EAAO,IAAIZ,EAAM,CAAC,CAAC,GAAI,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,IAAK,GACpDa,EAAW,IAAIb,EAAM,CAAC,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,GAAI,GAAI,EAAE,EAAG,IAAK,GACzDc,EAAkB,IAAId,EAAM,CAAC,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,GAAI,GAAI,EAAE,GAAI,IAAK,GACjEe,EAAiB,IAAIf,EAAM,CAAC,CAAC,GAAI,GAAI,CAAC,GAAI,GAAI,CAAC,EAAG,GAAI,EAAE,EAAG,IAAK,GAChEgB,EAAc,IAAIhB,EAAM,CAAC,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,EAAE,EAAG,GAAI,EAAE,GAAI,IAAK,GAC7DiB,EAAa,IAAIjB,EAAM,CAAC,EAAE,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,GAAI,IAAK,GAC3DkB,EAAS,IAAIlB,EAAM,CAAC,CAAC,GAAI,GAAI,CAAC,EAAG,GAAI,CAAC,GAAI,GAAI,CAAC,EAAG,IAAK,GC5B7CmB,E,kDACjB,WAAYlC,GAAQ,IAAD,8BACf,cAAMA,IACDmC,UAAY,GACjB,EAAKC,WAAa,GAClB,EAAKC,aAAe,IACpB,EAAKC,UAAY,CAACX,EAAMC,EAAUC,EAAiBC,EACnDC,EAAaC,EAAYC,GACzB,EAAKM,MAAQ,CACTC,WAAY,EAAKC,cAAc,EAAKL,WAAY,EAAKD,WACrDO,MAAO,EAAKC,iBACZzB,QAAS,EACTC,QAAS,EACTC,SAAU,EACVwB,OAAQ,GAbG,E,qDAiBnB,WACInC,KAAKoC,UAAYC,YAAYrC,KAAKsC,cAAcC,KAAKvC,MAAOA,KAAK4B,cACjEY,OAAOC,iBAAiB,UAAWzC,KAAK0C,gBAAgBH,KAAKvC,S,kCAGjE,WACI2C,cAAc3C,KAAKoC,WACnBQ,QAAQC,IAAI,a,6BAGhB,SAAgBC,GACU,KAAlBA,EAAMC,QACN/C,KAAKgD,gBACoB,KAAlBF,EAAMC,QACb/C,KAAKiD,SACoB,KAAlBH,EAAMC,QACb/C,KAAKkD,iBACoB,KAAlBJ,EAAMC,SACb/C,KAAKsC,kB,2BAIb,WACI,IAAIa,EAAanD,KAAK8B,MAAMrB,QAAU,EAClCC,EAAUV,KAAK8B,MAAMpB,QACrBC,EAAWX,KAAK8B,MAAMnB,SACpBX,KAAKoD,SAASD,EAAYzC,EAASC,IACrCX,KAAKqD,SAAS,CAAC5C,QAAS0C,M,4BAMhC,WACI,IAAIA,EAAanD,KAAK8B,MAAMrB,QAAU,EAClCC,EAAUV,KAAK8B,MAAMpB,QACrBC,EAAWX,KAAK8B,MAAMnB,SACpBX,KAAKoD,SAASD,EAAYzC,EAASC,IACrCX,KAAKqD,SAAS,CAAC5C,QAAS0C,M,oBAMhC,WACI,IAAI1C,EAAUT,KAAK8B,MAAMrB,QACrBC,EAAUV,KAAK8B,MAAMpB,QACrBC,EAAWX,KAAK8B,MAAMnB,SAC1B,GAAIA,GAAY,EACZ,IAAI2C,EAAc,OAEdA,EAAc3C,EAAW,EAE3BX,KAAKoD,SAAS3C,EAASC,EAAS4C,IAClCtD,KAAKqD,SAAS,CAAC1C,SAAU2C,M,2BAMjC,WACI,IAAI7C,EAAUT,KAAK8B,MAAMrB,QAErB8C,GADUvD,KAAK8B,MAAMpB,QACRV,KAAK8B,MAAMpB,QAAU,GAClCC,EAAWX,KAAK8B,MAAMnB,SAErBX,KAAKoD,SAAS3C,EAAS8C,EAAY5C,GAGpCX,KAAKwD,aAFLxD,KAAKqD,SAAS,CAAC3C,QAAS6C,M,sBAMhC,SAAS9C,EAASC,EAASC,GACvB,IADiC,EAC7BoB,EAAa/B,KAAK8B,MAAMC,WACxB0B,EAAezD,KAAK8B,MAAMG,MAAMyB,YAAYjD,EAASC,EAASC,GAFjC,cAGf8C,GAHe,IAGjC,2BAAgC,CAAC,IAAxBE,EAAuB,QAC5B,GAAIA,EAAM,GAAK,GAAKA,EAAM,IAAM3D,KAAK0B,WAAaiC,EAAM,IAAM3D,KAAK2B,WAC/D,OAAO,EAEX,GAAsC,GAAlCI,EAAW4B,EAAM,IAAIA,EAAM,IAC3B,OAAO,GARkB,8BAWjC,OAAO,I,wBAGX,WACIlE,EAAOO,KAAK4D,gBADH,MAEmB5D,KAAK6D,iBAAiBpE,GAFzC,mBAEJA,EAFI,KAEEqE,EAFF,KAGLC,EAAW/D,KAAKkC,iBAChB8B,EAAgBhE,KAAK8B,MAAMK,OAC/BnC,KAAKqD,SAAS,CAACtB,WAAYtC,EACvBwC,MAAO8B,EACPtD,QAAS,EACTC,QAAS,EACTC,SAAU,EACVwB,OAAQ6B,EAAgBF,M,8BAGhC,SAAiBrE,GACb,IAAIwE,EAAajE,KAAKkE,cAAczE,GACpCwE,EAAWE,MAAK,SAASC,EAAEC,GAAI,OAAOA,EAAED,KACxC,IAHmB,EAGfE,EAAQ,EAHO,cAIAL,GAJA,IAInB,2BAA+B,CAAC,IAAvBM,EAAsB,QAC3B9E,EAAK+E,OAAOD,EAAOD,EAAO,GAC1B7E,EAAK+E,OAAO,EAAG,EAAG,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,IACrCF,GAAS,GAPM,8BASnB,MAAO,CAAC7E,EAAMwE,EAAWrE,U,2BAG7B,SAAcH,GAEV,IADA,IAAIwE,EAAa,GACRtE,EAAE,EAAGA,EAAEF,EAAKG,OAAQD,IACrBK,KAAKyE,YAAYhF,EAAKE,KACtBsE,EAAWhE,KAAKN,GAGxB,OAAOsE,I,yBAGX,SAAYpE,GAAM,IAAD,gBACIA,GADJ,IACb,2BAAsB,CAClB,GAAa,IADK,QAEd,OAAO,GAHF,8BAMb,OAAO,I,2BAGX,SAAc8B,EAAYD,GAEtB,IADA,IAAIhC,EAAO,GACFG,EAAM,EAAGA,EAAM8B,EAAY9B,IAAO,CACvCH,EAAKO,KAAK,IACV,IAAK,IAAIyE,EAAM,EAAGA,EAAMhD,EAAWgD,IAC/BhF,EAAKG,GAAKI,KAAK,GAGvB,OAAOP,I,2BAGX,WAII,IAHA,IAAI+D,EAAezD,KAAK2E,yBACpBlF,EAAOO,KAAKgC,cAAchC,KAAK2B,WAAY3B,KAAK0B,WAE3C/B,EAAI,EAAGA,EAAIK,KAAK8B,MAAMC,WAAWnC,OAAQD,IAC9C,IAAK,IAAIG,EAAE,EAAGA,EAAIE,KAAK8B,MAAMC,WAAW,GAAGnC,OAAQE,IAC/CL,EAAKE,GAAGG,GAAKE,KAAK8B,MAAMC,WAAWpC,GAAGG,GANlC,oBAUM2D,GAVN,IAUZ,2BAAgC,CAAC,IAAxBE,EAAuB,QAC5BlE,EAAKkE,EAAM,IAAIA,EAAM,IAAM3D,KAAK8B,MAAMG,MAAMzB,OAXpC,8BAaZ,OAAOf,I,6BAGX,SAAgBgB,EAASC,EAASC,GAC9B,OAAOX,KAAK8B,MAAMG,MAAMyB,YAAYjD,EAASC,EAASC,K,oCAG1D,WACI,IAAIF,EAAUT,KAAK8B,MAAMrB,QACrBC,EAAUV,KAAK8B,MAAMpB,QACrBC,EAAWX,KAAK8B,MAAMnB,SAC1B,OAAOX,KAAK4E,gBAAgBnE,EAASC,EAASC,K,4BAGlD,WACI,IAAIkE,EAAcC,KAAKC,MAAMD,KAAKE,SAAShF,KAAK6B,UAAUjC,QAE1D,OADeI,KAAK6B,UAAUgD,K,oBAIlC,WACI,IAAIpF,EAAOO,KAAK4D,gBAChB,OAAO,qCACP,cAAC,EAAD,CAAM1D,UAAU,SAAST,KAAMA,EAC/BD,aAAc,CAAC,YAAa,WAAY,WAAY,aAAa,YAAa,eAC9E,qBAAKU,UAAU,SAAf,SAAyBF,KAAK8B,MAAMK,gB,GAtMR/B,IAAMC,W,MCF3B4E,MAPf,WAEE,OACE,cAAC,EAAD,KCLJC,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,W","file":"static/js/main.214f1782.chunk.js","sourcesContent":["import React from \"react\";\n\n\n// A Grid is intended to display a grid of squares of different colors.\n// It takes a 2d array of integers, each unique integer i in that array\n// maps the corresponding className colorClasses[i]\n\n// TODO:\n// -need to ensure that no value in grid is larger than the number\n// of colorClasses\n// -should we actually store a state rather than regenerating each time?\n// (could be important for speeding up larger grids)\n\nexport default class Grid extends React.Component {\n    constructor(props) {\n        super(props)\n        this.colorClasses = this.props.colorClasses\n    }\n\n    makeGrid(grid) {\n        var rows = []\n        for (var i = 0; i < grid.length; i++) {\n            var row = []\n            for (var j = 0; j < grid[0].length; j++) {\n                var colorClass = this.colorClasses[grid[i][j]]\n                row.push(<td key={\"col\" + i + j} className={colorClass}></td>)\n            }\n            rows.push(<tr key={\"row\" + i}>{row}</tr>)\n        }\n        return <table className={this.props.className}><tbody>{rows}</tbody></table>\n    }\n\n    render() {\n        return this.makeGrid(this.props.grid)\n    }\n}","\nclass Shape {\n    constructor(coords, color) {\n        this.coords = coords\n        this.color = color\n    }\n\n    makeIndices(centerX, centerY, rotation) {\n        if (rotation === 0) {\n            return this.makeRotationOne(centerX, centerY)\n        } else if (rotation === 1) {\n            return this.makeRotationTwo(centerX, centerY)\n        } else if (rotation === 2) {\n            return this.makeRotationThree(centerX, centerY)\n        } else if (rotation == 3) {\n            return this.makeRotationFour(centerX, centerY)\n        }\n    }\n\n    makeRotationOne(centerX, centerY) {\n        return this.coords.map(coord => [centerX+coord[0], centerY+coord[1]])\n    }\n\n    makeRotationTwo(centerX, centerY) {\n        return this.coords.map(coord => [centerX+coord[1], centerY+coord[0]])\n    }\n\n    makeRotationThree(centerX, centerY) {\n        return this.coords.map(coord => [centerX-coord[0], centerY-coord[1]])\n    }\n\n    makeRotationFour(centerX, centerY) {\n        return this.coords.map(coord => [centerX-coord[1], centerY-coord[0]])\n    }\n\n}\n\nexport var Line = new Shape([[0, -1], [0, 0], [0, 1], [0, 2]], 1)\nexport var TeeShape = new Shape([[0, 1], [0, 0], [0, -1], [-1, 0]], 2)\nexport var SnakeShapeRight = new Shape([[1, 0], [0, 0], [0, -1], [-1, -1]], 3)\nexport var SnakeShapeLeft = new Shape([[1, -1], [0, -1], [0, 0], [-1, 0]], 3)\nexport var LShapeRight = new Shape([[1, 0], [0, 0], [-1, 0], [-1, -1]], 4)\nexport var LShapeLeft = new Shape([[-1, 0], [0, 0], [1, 0], [1, -1]], 4)\nexport var Square = new Shape([[0, -1], [0, 0], [1, -1], [1, 0]], 5)\n\n\n// export class LShapeRight {\n\n//     constructor() {\n//         this.color = 4\n//     }\n\n//     makeIndices(centerX, centerY, rotation) {\n//         if (rotation === 0) {\n//             return this.makeRotationOne(centerX, centerY)\n//         } else if (rotation === 1) {\n//             return this.makeRotationTwo(centerX, centerY)\n//         } else if (rotation === 2) {\n//             return this.makeRotationThree(centerX, centerY)\n//         } else if (rotation == 3) {\n//             return this.makeRotationFour(centerX, centerY)\n//         }\n//     }\n    \n//     [[1, 0], [0, 0], [-1, 0], [-1, -1]]\n//     makeRotationOne(centerX, centerY) {\n//         var square1 = [centerX+1, centerY]\n//         var square2 = [centerX, centerY]\n//         var square3 = [centerX-1, centerY]\n//         var square4 = [centerX-1, centerY-1]\n//         return [square1, square2, square3, square4]\n//     }\n\n//     makeRotationTwo(centerX, centerY) {\n//         var square1 = [centerX, centerY+1]\n//         var square2 = [centerX, centerY]\n//         var square3 = [centerX, centerY-1]\n//         var square4 = [centerX+1, centerY+1]\n//         return [square1, square2, square3, square4]\n//     }\n\n//     makeRotationThree(centerX, centerY) {\n//         var square1 = [centerX-1, centerY]\n//         var square2 = [centerX, centerY]\n//         var square3 = [centerX+1, centerY]\n//         var square4 = [centerX+1, centerY+1]\n//         return [square1, square2, square3, square4]\n//     }\n\n//     makeRotationFour(centerX, centerY) {\n//         var square1 = [centerX, centerY-1]\n//         var square2 = [centerX, centerY]\n//         var square3 = [centerX, centerY+1]\n//         var square4 = [centerX-1, centerY-1]\n//         return [square1, square2, square3, square4]\n//     }\n// }\n\n// export class LShapeLeft {\n\n//     constructor() {\n//         this.color = 4\n//     }\n\n//     makeIndices(centerX, centerY, rotation) {\n//         if (rotation === 0) {\n//             return this.makeRotationOne(centerX, centerY)\n//         } else if (rotation === 1) {\n//             return this.makeRotationTwo(centerX, centerY)\n//         } else if (rotation === 2) {\n//             return this.makeRotationThree(centerX, centerY)\n//         } else if (rotation == 3) {\n//             return this.makeRotationFour(centerX, centerY)\n//         }\n//     }\n\n//     [[-1, 0], [0, 0], [1, 0], [1, -1]]\n//     makeRotationOne(centerX, centerY) {\n//         var square1 = [centerX-1, centerY]\n//         var square2 = [centerX, centerY]\n//         var square3 = [centerX+1, centerY]\n//         var square4 = [centerX+1, centerY-1]\n//         return [square1, square2, square3, square4]\n//     }\n\n//     makeRotationTwo(centerX, centerY) {\n//         var square1 = [centerX, centerY+1]\n//         var square2 = [centerX, centerY]\n//         var square3 = [centerX, centerY-1]\n//         var square4 = [centerX-1, centerY+1]\n//         return [square1, square2, square3, square4]\n//     }\n\n//     makeRotationThree(centerX, centerY) {\n//         var square1 = [centerX+1, centerY]\n//         var square2 = [centerX, centerY]\n//         var square3 = [centerX-1, centerY]\n//         var square4 = [centerX-1, centerY+1]\n//         return [square1, square2, square3, square4]\n//     }\n\n//     makeRotationFour(centerX, centerY) {\n//         var square1 = [centerX, centerY-1]\n//         var square2 = [centerX, centerY]\n//         var square3 = [centerX, centerY+1]\n//         var square4 = [centerX+1, centerY-1]\n//         return [square1, square2, square3, square4]\n//     }\n// }\n\n\n// export class Square {\n\n//     constructor() {\n//         this.color = 5\n//     }  \n    \n//     makeIndices(centerX, centerY, rotation) {\n//         if (rotation === 0) {\n//             return this.makeRotationOne(centerX, centerY)\n//         } else if (rotation === 1) {\n//             return this.makeRotationOne(centerX, centerY)\n//         } else if (rotation === 2) {\n//             return this.makeRotationOne(centerX, centerY)\n//         } else if (rotation == 3) {\n//             return this.makeRotationOne(centerX, centerY)\n//         }\n//     }\n\n//     [[0, -1], [0, 0], [1, -1], [1, 0]]\n//     makeRotationOne(centerX, centerY) {\n//         var topLeft = [centerX, centerY-1]\n//         var topRight = [centerX, centerY]\n//         var bottomLeft = [centerX+1, centerY-1]\n//         var bottomRight = [centerX+1, centerY]\n//         return [topLeft, topRight, bottomLeft, bottomRight]\n//     }\n// }","import React from \"react\";\nimport Grid from \"./Grid.js\";\nimport { Line, TeeShape, SnakeShapeRight, SnakeShapeLeft,\nLShapeRight, LShapeLeft, Square } from \"../shapes.js\";\n\n\n// TODO: different colors for different shapes\n// todo: beveled edges\n// TODO: game over when overflow at top\n// TODO: increment points when row filled\n// TODO: sound when row filled\n// TODO: display points\n// TODO: speed up with point total (new level every four points)\n// TODO: soft code the rotations\n\nexport default class Tetris extends React.Component {\n    constructor(props) {\n        super(props)\n        this.gridWidth = 10\n        this.gridHeight = 20\n        this.fallingSpeed = 500\n        this.allShapes = [Line, TeeShape, SnakeShapeRight, SnakeShapeLeft,\n        LShapeRight, LShapeLeft, Square]\n        this.state = {\n            staticGrid: this.makeEmptyGrid(this.gridHeight, this.gridWidth),\n            shape: this.getRandomShape(),\n            centerX: 4,\n            centerY: 1,\n            rotation: 0,\n            points: 0\n        }\n    }\n\n    componentDidMount() {\n        this.dropShape = setInterval(this.moveShapeDown.bind(this), this.fallingSpeed)\n        window.addEventListener('keydown', this.handleUserInput.bind(this))\n    }\n\n    componentWillUnmount() {\n        clearInterval(this.dropShape)\n        console.log('unmount')\n    }\n\n    handleUserInput(event) {\n        if (event.keyCode === 37) { // left arrow\n            this.moveShapeLeft()\n        } else if (event.keyCode === 38) { // up arrow\n            this.rotate()\n        } else if (event.keyCode === 39) { // right arrow\n            this.moveShapeRight()\n        } else if (event.keyCode === 40) { // down arrow\n            this.moveShapeDown()\n        }\n    }\n\n    moveShapeLeft() {\n        var newCenterX = this.state.centerX - 1\n        var centerY = this.state.centerY\n        var rotation = this.state.rotation\n        if (!(this.collides(newCenterX, centerY, rotation))) {\n            this.setState({centerX: newCenterX})\n        } else {\n            ;\n        }\n    }\n\n    moveShapeRight() {\n        var newCenterX = this.state.centerX + 1\n        var centerY = this.state.centerY\n        var rotation = this.state.rotation\n        if (!(this.collides(newCenterX, centerY, rotation))) {\n            this.setState({centerX: newCenterX})\n        } else {\n            ;\n        }\n    }\n\n    rotate() {\n        var centerX = this.state.centerX\n        var centerY = this.state.centerY\n        var rotation = this.state.rotation\n        if (rotation >= 3) {\n            var newRotation = 0\n        } else {\n            var newRotation = rotation + 1\n        }\n        if (!(this.collides(centerX, centerY, newRotation))) {\n            this.setState({rotation: newRotation})\n        } else {\n            ;\n        }\n    }\n\n    moveShapeDown() {\n        var centerX = this.state.centerX\n        var centerY = this.state.centerY\n        var newCenterY = this.state.centerY + 1\n        var rotation = this.state.rotation\n        // we check if then new shapeIndices collide before changing the state\n        if (!this.collides(centerX, newCenterY, rotation)) {\n            this.setState({centerY: newCenterY})\n        } else {\n            this.resetShape()\n        }\n    }\n\n    collides(centerX, centerY, rotation) {\n        var staticGrid = this.state.staticGrid\n        var shapeIndices = this.state.shape.makeIndices(centerX, centerY, rotation)\n        for (var index of shapeIndices) {\n            if (index[0] < 0 || index[0] >= this.gridWidth || index[1] >= this.gridHeight)  {\n                return true\n            }\n            if (staticGrid[index[1]][index[0]] != 0) {\n                return true\n            }\n        }\n        return false\n    }\n\n    resetShape() {\n        grid = this.joinShapeGrid()\n        var [grid, numFilledrows] = this.removeFilledRows(grid)\n        var newShape = this.getRandomShape()\n        var currentPoints = this.state.points\n        this.setState({staticGrid: grid, \n            shape: newShape, \n            centerX: 4, \n            centerY: 1, \n            rotation: 0,\n            points: currentPoints + numFilledrows})\n    }\n\n    removeFilledRows(grid) {\n        var filledRows = this.getFilledRows(grid)\n        filledRows.sort(function(a,b) {return b-a}) // we have to remove the rows in order\n        var count = 0\n        for (var rowNum of filledRows) {   \n            grid.splice(rowNum+count, 1) // remove the row \n            grid.splice(0, 0, [0,0,0,0,0,0,0,0,0,0]) // put an empty row at the top\n            count += 1\n        }\n        return [grid, filledRows.length]\n    }\n\n    getFilledRows(grid) {\n        var filledRows = []\n        for (var i=0; i<grid.length; i++) {\n            if (this.isFilledRow(grid[i])) {\n                filledRows.push(i)\n            }\n        }\n        return filledRows\n    }\n\n    isFilledRow(row) {\n        for (var cell of row) {\n            if (cell === 0) {\n                return false\n            }\n        }\n        return true\n    }\n\n    makeEmptyGrid(gridHeight, gridWidth) {\n        var rows = []\n        for (var row = 0; row < gridHeight; row++) {\n            rows.push([])\n            for (var col = 0; col < gridWidth; col++) {\n                rows[row].push(0)\n            }\n        }\n        return rows\n    }\n\n    joinShapeGrid() {\n        var shapeIndices = this.getCurrentShapeIndices()\n        var grid = this.makeEmptyGrid(this.gridHeight, this.gridWidth)\n        // copy static grid\n        for (var i = 0; i < this.state.staticGrid.length; i++) {\n            for (var j=0; j < this.state.staticGrid[0].length; j++) {\n                grid[i][j] = this.state.staticGrid[i][j]\n            }\n        }\n        // copy the current shape\n        for (var index of shapeIndices) {\n            grid[index[1]][index[0]] = this.state.shape.color\n        }\n        return grid\n    }\n\n    getShapeIndices(centerX, centerY, rotation) {\n        return this.state.shape.makeIndices(centerX, centerY, rotation)\n    }\n\n    getCurrentShapeIndices() {\n        var centerX = this.state.centerX\n        var centerY = this.state.centerY\n        var rotation = this.state.rotation\n        return this.getShapeIndices(centerX, centerY, rotation)\n    }\n\n    getRandomShape() {\n        var randomIndex = Math.floor(Math.random()*this.allShapes.length)\n        var newShape = this.allShapes[randomIndex]\n        return newShape\n    }\n\n    render() {\n        var grid = this.joinShapeGrid()\n        return <>\n        <Grid className=\"tetris\" grid={grid} \n        colorClasses={[\"colorZero\", \"colorOne\", \"colorTwo\", \"colorThree\",\"colorFour\", \"colorFive\"]}/>\n        <div className=\"points\">{this.state.points}</div>\n        </>\n    }\n}","import Grid from './components/Grid.js';\nimport Tetris from './components/Tetris.js';\nimport './App.css';\n\n\n\nfunction App() {\n  var values = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n  return (\n    <Tetris />\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}